# Архитектура CLI

## Архитектурное описание

* `Main` запускает интерпретатор и синхронизирует работу всех компонентов. Он же отвечает за "аккуратное" завершение работы шелла.

* `CommandLine` отвечает за взаимодействие пользователя с интерпретатором (чтение и запись).

* `Environment` Хранит переменные среды, даёт к ним доступ

### Парсинг

* `Parser` задаётся входной строкой и преобразует её в последовательность команд для исполнения. Здесь реализован паттерн "Состояние", с помощью которого реализуется "умная" токенизация: все переменные среды сразу подставляются (предполагается, что новые переменные появиться не могут).

* `TokenizerState` отвечает за токенизацию: начинаем с `TokenizerNormal` и
  * Если встречаем одиночную кавычку, то переходим в состояние `TokenizerStronglyQuoted` и всё, что идёт до второй одиночной кавычки накапливается (это контролируется полем `splitters`). `tokenize()` же просто переводит накопленный результат в `QuotedString`.
  * Если встречаем доллар (`$`), то переходим в состояние `TokenizerVariable`, накапливаем до пробела или скобки и накопленное переводится с помощью `tokenize()` в значение из переменных среды.
  * Если встречаем двойную кавычку, то переходим в состояние `TokenizerWeaklyQuoted`, тут возможна подстановка переменной среды, тут алгоритм не отличается от вышеприведённого кроме того, что можем накапливать ещё и до двойной кавычки.

* `Token` содержит либо знак равенства (`=`), либо пайп (`|`), либо строку в кавычках (тут неважно, в каких), либо просто какую-то непрерывающуюся последовательность символов (названная `PlainWord`).

### Исполнение команд

* `CommandRunner` исполняет команды в заданном порядке, отвечает за передачу выхода одной команды на вход другой и передачу итогового ответа. На этапе исполнения переменные среды могут только добавляться (или перезаписываться).

* `CommandQueue` содержит очередь команд. По сути хранит порядок, заданный пайпами.

* `Command` является абстракцией команд, которые создаются на моменте парсинга.
  * `Cat`, `Pwd`, `Echo`, `Wc`, `Exit`, `Bind` -- реализуют команды из задания (`Bind` отвечает за назначение переменной среды).
  * `External` помимо переопределения метода `execute()` должен также предварительно проверять, есть ли в какой-нибудь из указанных директорий с исполнимыми файлами такая команда или, если команда содержит абсолютный путь, проверяет непосредственно этот файл. Если нет, то `executableExists()` сигнализирует об ошибке.

* `Output` содержит результат выполнения команды.

## Процесс работы приложения

Приложение работает по следующему алгоритму

1. Запускаем интерпретатор.
2. Вводим команду/ы в консоль
3. `Parser`, предварительно подставив все известные переменные среды
там, где это имеет смысл, разбивает строку на синтаксические части.
4. `CommandRunner`, следуя полученной инструкции от `Parser`, запускает нужные методы через абстрактный класс `Command`.

## Добавление новой команды

Для добавления новой команды необходимо

* Создать новый класс, реализующий интерфейс Command.
* Модифицировать Parser.
